generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  user_id           Int            @id @default(autoincrement())
  name              String         @db.VarChar(100)
  surname           String         @db.VarChar(100)
  email             String         @unique @db.VarChar(150)
  password_hash     String         @db.VarChar(255)
  birth_date        DateTime?      @db.Date
  registration_date DateTime?      @default(now()) @db.Timestamp(6)
  loan              loan[]
  subscription      subscription[]
}

model author {
  author_id  Int          @id @default(autoincrement())
  name       String       @db.VarChar(100)
  surname    String       @db.VarChar(100)
  birth_date DateTime?    @db.Date
  country_id Int?
  country    country?     @relation(fields: [country_id], references: [country_id], onUpdate: NoAction)
  bookauthor bookauthor[]
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
model book {
  book_id          Int          @id @default(autoincrement())
  publisher_id     Int?
  name             String       @db.VarChar(200)
  isbn             String       @unique @db.VarChar(20)
  publication_date DateTime?    @db.Date
  pages_count      Int?
  publisher        publisher?   @relation(fields: [publisher_id], references: [publisher_id], onUpdate: NoAction)
  bookauthor       bookauthor[]
  bookgenre        bookgenre[]
  loan             loan[]
}

model bookauthor {
  book_id   Int
  author_id Int
  author    author @relation(fields: [author_id], references: [author_id], onDelete: Cascade, onUpdate: NoAction)
  book      book   @relation(fields: [book_id], references: [book_id], onDelete: Cascade, onUpdate: NoAction)

  @@id([book_id, author_id])
}

model bookgenre {
  book_id  Int
  genre_id Int
  book     book  @relation(fields: [book_id], references: [book_id], onDelete: Cascade, onUpdate: NoAction)
  genre    genre @relation(fields: [genre_id], references: [genre_id], onDelete: Cascade, onUpdate: NoAction)

  @@id([book_id, genre_id])
}

model country {
  country_id Int         @id @default(autoincrement())
  name       String      @unique @db.VarChar(100)
  author     author[]
  publisher  publisher[]
}

model genre {
  genre_id    Int         @id @default(autoincrement())
  name        String      @unique @db.VarChar(100)
  description String?
  bookgenre   bookgenre[]
}

model loan {
  loan_date       DateTime      @default(now()) @db.Timestamp(6)
  user_id         Int
  book_id         Int
  status          loan_status
  access_end_date DateTime?     @db.Date
  subscription_id Int?
  book            book          @relation(fields: [book_id], references: [book_id], onDelete: Cascade, onUpdate: NoAction)
  subscription    subscription? @relation(fields: [subscription_id], references: [subscription_id], onUpdate: NoAction)
  User            User          @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction)

  @@id([loan_date, user_id, book_id])
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
model payment {
  payment_id      Int            @id @default(autoincrement())
  subscription_id Int
  amount          Decimal?       @db.Decimal(8, 2)
  payment_date    DateTime?      @default(now()) @db.Timestamp(6)
  payment_type    payment_type
  status          payment_status
  subscription    subscription   @relation(fields: [subscription_id], references: [subscription_id], onDelete: Cascade, onUpdate: NoAction)
}

model publisher {
  publisher_id Int       @id @default(autoincrement())
  name         String    @db.VarChar(150)
  founded_date DateTime? @db.Date
  country_id   Int?
  book         book[]
  country      country?  @relation(fields: [country_id], references: [country_id], onUpdate: NoAction)
}

model subscription {
  subscription_id Int                 @id @default(autoincrement())
  user_id         Int
  start_date      DateTime            @db.Date
  end_date        DateTime            @db.Date
  type            subscription_type
  status          subscription_status
  loan            loan[]
  payment         payment[]
  User            User                @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction)
}

enum loan_status {
  ACTIVE
  RETURNED
  EXPIRED
}

enum payment_status {
  COMPLETED
  PENDING
  FAILED
}

enum payment_type {
  CARD
  PAYPAL
  CRYPTO
}

enum subscription_status {
  ACTIVE
  EXPIRED
  CANCELLED
}

enum subscription_type {
  TRIAL
  STANDARD
  PREMIUM
}
